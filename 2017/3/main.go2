package main

import (
	"encoding/json"
	"fmt"

	"github.com/loganbickmore/advent-of-code/utils"
)

var input = 277678

// genMatrix creates a matrix n*n in size and accepts a target number
// returns a 2d slice in a spiral format, target coords and center coords
func genMatrix(n int) [][]int {
	// lots of help from  http://www.geeksforgeeks.org/print-n-x-n-spiral-matrix-using-o1-extra-space/
	m := [][]int{}
	for i := 0; i < n; i++ {
		mN := []int{}
		for j := 0; j < n; j++ {
			var x int
			x = utils.Min(utils.Min(i, j), utils.Min(n-1-i, n-1-j))

			if i <= j { // upper right
				num := (n-2*x)*(n-2*x) - (i - x) - (j - x)
				//fmt.Printf("%2d ", num)
				mN = append(mN, num)

			} else { // lower left
				num := (n-2*x-2)*(n-2*x-2) + (i - x) + (j - x)
				//fmt.Printf("%2d ", num)
				mN = append(mN, num)
			}
		}
		m = append(m, mN)
		//fmt.Println()
	}
	return m
}

func getCoords(m [][]int, t int) ([]int, []int) {
	var tar, cen []int
	for i, row := range m {
		for j, n := range row {
			if n == t {
				tar = []int{i, j}
			}
			if n == 1 {
				cen = []int{i, j}
			}
		}
	}
	return tar, cen
}

func main() {
	// part 2
	p2()
	return
	m := genMatrix(530) //530x530 contains the target of input
	tar, cen := getCoords(m, input)
	fmt.Println("Testcases")
	fmt.Println("1: expect 0 ->", utils.Dist(getCoords(m, 1)))
	fmt.Println("12: expect 3 ->", utils.Dist(getCoords(m, 12)))
	fmt.Println("23: expect 2 ->", utils.Dist(getCoords(m, 23)))
	fmt.Println("1024: expect 31 ->", utils.Dist(getCoords(m, 1024)))

	fmt.Println("Part1 ->", utils.Dist(tar, cen))
}

type l struct {
	x int
	y int
}
type data map[l]int

func sum(input ...int) int {
	sum := 0
	for i := range input {
		sum += input[i]
	}
	return sum
}
func (d data) gen(lx, ly int) int {
	n := sum(
		d[l{lx - 1, ly + 1}], // [-1, 1]
		d[l{lx, ly + 1}],     // [ 0, 1]
		d[l{lx + 1, ly + 1}], // [ 1, 1]
		d[l{lx - 1, ly}],     // [-1, 0]
		d[l{lx + 1, ly}],     // [ 1, 0]
		d[l{lx - 1, ly - 1}], // [-1,-1]
		d[l{lx, ly - 1}],     // [ 0,-1]
		d[l{lx + 1, ly - 1}], // [ 1,-1]
	)
	d[l{lx, ly}] = n
	return n
}

//
// INFINITE RECURSION, ADD A BETTER METHOD OF ENSURING THAT DOESNT HAPPEN
//
func (d data) step(lx, ly int, dir l) (int, int) {
	x := d[l{lx + dir.x, ly + dir.y}]
	/*
		left := d[l{lx - 1, ly}]
		right := d[l{lx + 1, ly}]
		down := d[l{lx, ly - 1}]
		up := d[l{lx, ly + 1}]
	*/
	if x == 0 {
		d.step(lx, ly, dir)
	}
	d.gen(lx, ly)
	ly += dir.y
	lx += dir.x

	return lx, ly
}

func (d data) goUp(lx, ly int) {
	if end(lx, ly) {
		return
	}
	left := d[l{lx - 1, ly}]
	if left == 0 {
		d.goLeft(lx, ly)
	}
	ly++
	d.gen(lx, ly)
	d.goUp(lx, ly)
}
func (d data) goDown(lx, ly int) {
	if end(lx, ly) {
		return
	}
	right := d[l{lx + 1, ly}]
	if right == 0 {
		d.goRight(lx, ly)
	}
	ly--
	d.gen(lx, ly)
	d.goDown(lx, ly)

}
func (d data) goLeft(lx, ly int) {
	if end(lx, ly) {
		return
	}
	down := d[l{lx, ly - 1}]
	if down == 0 {
		d.goDown(lx, ly)
	}
	lx--
	d.gen(lx, ly)
	d.goLeft(lx, ly)
}
func (d data) goRight(lx, ly int) {
	if end(lx, ly) {
		return
	}
	up := d[l{lx, ly + 1}]
	if up == 0 {
		d.goUp(lx, ly)
	}
	lx++
	d.gen(lx, ly)
	return
	d.goRight(lx, ly)
}

// end once lx hits defined end to break
func end(lx, ly int) bool {
	n := 2
	if utils.Abs(lx) >= n {
		return true
	}
	if utils.Abs(ly) >= n {
		return true
	}
	return false
}
func p2() {
	d := make(data)
	d[l{0, 0}] = 1
	lx := 1
	ly := 0
	//up := d[l{lx, ly + 1}]
	//fmt.Println(up)
	//return
	/*
		d.gen(1, 0)
		d.gen(1, 1)
		d.gen(0, 1)
		d.gen(-1, 1)
		d.gen(-1, 0)
		d.gen(-1, -1)
		d.gen(0, -1)
		d.gen(1, -1)
		lx := 2
		ly := -1
		fmt.Println(d.gen(lx, ly))
		fmt.Printf("%#v", d)
	*/

	//for i := 0; i < 5; i++ {
	//d.goRight(lx, ly)
	d.step(lx, ly, l{1, 0})
	fmt.Printf("%#v", d)
	j, _ := json.Marshal(d)
	fmt.Println(j)

	/*
		[-1, 1], [0, 1], [1, 1]
		[-1, 0], [0, 0], [1, 0]
		[-1,-1], [0,-1], [1,-1]
	*/
	//}
}
